rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Utils
    function isMember(groupId, uid){
      return exists(/databases/$(database)/documents/groups/$(groupId)/members/$(uid));
    }

    function isAdmin(groupId, uid){
      return get(/databases/$(database)/documents/groups/$(groupId)).data.createdBy == uid;
    }

    function getInvite(groupId, inviteId){
      return get(/databases/$(database)/documents/groups/$(groupId)/invites/$(inviteId));
    }

    // Users
    match /users/{userId} {
      allow create: if (
        userId == request.auth.uid
        && request.resource.data.createdAt == request.time
        && request.resource.data.keys().hasAll(["createdAt", "username"])
      );
      allow update: if (
        userId == request.auth.uid
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(["username", "pfp"])
      );
      allow delete: if (
        userId == request.auth.uid
      );
      allow get, list: if (
        request.auth != null
      );
    }

    // Groups
    match /groups/{groupId} {
      allow create: if (
        request.auth.uid != null
        && request.resource.data.createdBy == request.auth.uid
        && request.resource.data.createdAt == request.time
        && request.resource.data.keys().hasAll(["name", "createdAt", "createdBy"])
      );
      allow update: if (
        resource.data.createdBy == request.auth.uid
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(["name", "icon"])
      );
      allow delete: if (
        resource.data.createdBy == request.auth.uid
      );
      allow get: if (
        resource.data.createdBy == request.auth.uid
        || isMember(groupId, request.auth.uid)
      );
    }

    // Members
    match /groups/{groupId}/members/{memberId} {
      allow create: if (
        memberId == request.auth.uid
        && request.resource.data.uid == request.auth.uid
        && request.resource.data.keys().hasOnly(["uid", "inviteId"])
        && (
          isAdmin(groupId, request.auth.uid)
          || getInvite(groupId, request.resource.data.inviteId).data.expiresAt > request.time
        )
      );
      // This allows users to set and remove their own uids,
      // while only allowing admins to remove them.
      allow update: if (
        (
          (
            memberId == request.auth.uid
            && (
              request.resource.data.uid == request.auth.uid
              || request.resource.data.uid == ""
            )
          )
          || (
            isAdmin(groupId, request.auth.uid)
            && request.resource.data.uid == ""
          )
        )
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(["uid"])
      );
      // Deleting a user is done by setting their "uid" field to an empty string.
      // This circumvents an issue where onSnapshot isn't called when a document is a query was deleted.
      allow delete: if false;
      allow get, list: if (
        isMember(groupId, request.auth.uid)
      );
    }

    match /{path=**}/members/{memberId} {
      allow get, list: if (
        resource.data.uid == request.auth.uid
        && resource.data != null
      );
    }

    // Chats
    match /groups/{groupId}/chats/{chatId} {
      allow create: if (
        isAdmin(groupId, request.auth.uid)
        && request.resource.data.createdAt == request.time
        && request.resource.data.keys().hasAll(["name", "createdAt"])
      );
      allow update: if (
        isAdmin(groupId, request.auth.uid)
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(["name"])
      );
      allow delete: if (
        isAdmin(groupId, request.auth.uid)
      );
      allow get, list: if (
        isMember(groupId, request.auth.uid)
      );
    }

    // Messages
    match /groups/{groupId}/chats/{chatId}/messages/{messageId} {
      allow create: if (
        isMember(groupId, request.auth.uid)
        && request.resource.data.createdBy == request.auth.uid
        && request.resource.data.createdAt == request.time
        && request.resource.data.keys().hasAll(["payload", "createdAt", "createdBy"])
      );
      allow update: if (
        (
          resource.data.createdBy == request.auth.uid
          || (
            isAdmin(groupId, request.auth.uid)
            && request.resource.data.payload == "__deleted__"
          )
        )
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(["payload"])
      )
      // Deletion is done by changing the payload to "__deleted__"
      allow delete: if false;
      allow get, list: if (
        isMember(groupId, request.auth.uid)
      )
    }

    // Folder
    match /groups/{groupId}/folders/{folderId} {
     allow create: if (
        isAdmin(groupId, request.auth.uid) 
        && request.resource.data.createdAt == request.time
        && request.resource.data.keys().hasAll(["name", "createdAt"])
      );
      allow update: if (
        isAdmin(groupId, request.auth.uid)
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(["name"])
      );
      allow delete: if (
        isAdmin(groupId, request.auth.uid)
      );
      allow get, list: if (
        isMember(groupId, request.auth.uid)
      );
    }

    // Files
    match /groups/{groupId}/folders/{folderId}/files/{fileId} {
      allow create: if (
        isMember(groupId, request.auth.uid)
        && request.resource.data.createdBy == request.auth.uid
        && request.resource.data.createdAt == request.time
        && request.resource.data.keys().hasAll(["name", "url", "createdAt", "createdBy"])
      );
      allow update: if false;
      allow delete: if (
        resource.data.createdBy == request.auth.uid
        || isAdmin(groupId, request.auth.uid)
      );
      allow get, list: if (
        isMember(groupId, request.auth.uid)
      );
    }

    // Calls
    match /groups/{groupId}/calls/{callId} {
      allow create: if (
        isAdmin(groupId, request.auth.uid)
        && request.resource.data.createdAt == request.time
        && request.resource.data.keys().hasAll(["name", "createdAt"])
      );
      allow update: if (
        isAdmin(groupId, request.auth.uid)
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(["name"])
      );
      allow delete: if (
        isAdmin(groupId, request.auth.uid)
      );
      allow get, list: if (
        isMember(groupId, request.auth.uid)
      );
    }

    // Participants
    match /groups/{groupId}/calls/{chatId}/participants/{uid} {
      allow create: if (
        isMember(groupId, request.auth.uid)
        && uid == request.auth.uid
        && request.resource.data.joinedAt == request.time
        && request.resource.data.keys().hasAll(["joinedAt", "isMuted", "sessionId"])
      );
      allow update: if (
        uid == request.auth.uid
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(["isMuted"])
      )
      allow delete: if (
        uid == request.auth.uid
        || isAdmin(groupId, request.auth.uid)
      )
      allow get, list: if (
        isMember(groupId, request.auth.uid)
      )
    }

    // NOTE: This technically allows someone to "snipe" another person
    // by creating a doc with the sessionId first in order to "steal"
    // the connection, but only members of the group can do this and
    // it's pointless, because, if you're in a call, your IP is public
    // to the other members of the group anyway.
    match /groups/{groupId}/calls/{chatId}/sessions/{sessionId}/peers/{peerId} {
      allow create, get: if (
        isMember(groupId, request.auth.uid)
      )
    }
    match /groups/{groupId}/calls/{chatId}/sessions/{sessionId}/peers/{peerId}/candidates/{candidateId} {
      allow create, get, list: if (
        isMember(groupId, request.auth.uid)
      )
    }

    // Boards
    match /groups/{groupId}/boards/{boardId} {
     allow create: if (
        isAdmin(groupId, request.auth.uid) 
        && request.resource.data.createdAt == request.time
        && request.resource.data.keys().hasAll(["name", "createdAt"])
      );
      allow update: if (
        isAdmin(groupId, request.auth.uid)
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(["name"])
      );
      allow delete: if (
        isAdmin(groupId, request.auth.uid)
      );
      allow get, list: if (
        isMember(groupId, request.auth.uid)
      );
    }

    // Tasks
    match /groups/{groupId}/boards/{boardId}/tasks/{taskId} {
      allow create: if (
        isMember(groupId, request.auth.uid)
        && request.resource.data.createdBy == request.auth.uid
        && request.resource.data.createdAt == request.time
        && request.resource.data.keys().hasAll(["name", "description", "assignedTo", "createdAt", "createdBy"])
      );
      allow update: if (
        (
          resource.data.createdBy == request.auth.uid
          || isAdmin(groupId, request.auth.uid)
        )
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(["name", "description"])
      )
      allow delete: if (
        resource.data.createdBy == request.auth.uid
        || isAdmin(groupId, request.auth.uid)
      );
      allow get, list: if (
        isMember(groupId, request.auth.uid)
      );
    }

    // Invites
    match /groups/{groupId}/invites/{inviteId} {
      allow create: if (
        isAdmin(groupId, request.auth.uid)
        && request.resource.data.keys().hasAll(["expiresAt"])
      )
      allow update: if false;
      allow delete: if (
        isAdmin(groupId, request.auth.uid)
      );
      allow get: if (
        request.auth != null
      )
      allow list: if (
        isAdmin(groupId, request.auth.uid)
      );
    }

  }
}